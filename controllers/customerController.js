import Customer from "../models/Customer.js";
import generateToken from "../utils/generateToken.js";

// Create a wrapper to handle errors in async functions
const tryCatch = (controller) => async (req, res, next) => {
  try {
    await controller(req, res);
  } catch (error) {
    res.status(error.statusCode || 500).json({
      message: error.message || "Server Error",
    });
  }
};

// @desc    Get all customers
// @route   GET /api/customers
// @access  Private/Admin
const getCustomers = tryCatch(async (req, res) => {
  // Check if we need to apply pagination
  const isPaginationRequired =
    req.query.page !== undefined || req.query.limit !== undefined;

  // Query parameters with defaults
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 10;
  const search = req.query.search || "";
  const sortField = req.query.sortField || "customerNo";
  const sortOrder = req.query.sortOrder || "asc";

  // Filter parameters - these are optional
  const isActive =
    req.query.isActive !== undefined
      ? req.query.isActive === "true"
      : undefined;
  const milkType = req.query.milkType || undefined;
  const subcategory = req.query.subcategory || undefined;

  // Prepare conditions object - starts empty to get all data by default
  const conditions = {};

  // Only add search conditions if search term exists
  if (search) {
    conditions.$or = [
      { name: { $regex: search, $options: "i" } },
      { phoneNo: { $regex: search, $options: "i" } },
      { address: { $regex: search, $options: "i" } },
    ];

    // Only add customerNo search if it could be a number
    if (!isNaN(parseInt(search))) {
      conditions.$or.push({ customerNo: parseInt(search) });
    }
  }

  // Only add filter conditions if they actually exist
  if (isActive !== undefined) {
    conditions.isActive = isActive;
  }

  if (milkType) {
    conditions['deliverySchedule.milkItems.milkType'] = milkType;
  }

  if (subcategory) {
    conditions['deliverySchedule.milkItems.subcategory'] = subcategory;
  }

  // Prepare sort object
  const sort = {};
  sort[sortField] = sortOrder === "asc" ? 1 : -1;

  // Base query without pagination
  let customersQuery = Customer.find(conditions)
    .populate({
      path: 'deliverySchedule',
      populate: {
        path: 'milkItems',
        populate: [
          { path: 'milkType', select: 'name' },
          { path: 'subcategory', select: 'name price' }
        ]
      }
    })
    .sort(sort)
    .lean();

  // Apply pagination only if required
  if (isPaginationRequired) {
    const skip = (page - 1) * limit;
    customersQuery = customersQuery.skip(skip).limit(limit);
  }

  // Execute queries
  const [total, customers] = await Promise.all([
    Customer.countDocuments(conditions),
    customersQuery,
  ]);
  // Calculate pagination data (only if pagination is applied)
  const totalPages = isPaginationRequired ? Math.ceil(total / limit) : 1;
  const hasMore = isPaginationRequired ? page < totalPages : false;

  // Return response
  res.json({
    customers,
    page: isPaginationRequired ? page : 1,
    limit: isPaginationRequired ? limit : total,
    totalPages,
    totalCustomers: total,
    hasMore,
  });
});

// @desc    Get customer by ID
// @route   GET /api/customers/:id
// @access  Private/Admin
const getCustomerById = tryCatch(async (req, res) => {
  const customer = await Customer.findById(req.params.id)
    .populate({
      path: 'deliverySchedule',
      populate: {
        path: 'milkItems',
        populate: [
          { path: 'milkType', select: 'name' },
          { path: 'subcategory', select: 'name price' }
        ]
      }
    });

  if (customer) {
    res.json(customer);
  } else {
    res.status(404).json({ message: "Customer not found" });
  }
});

// Helper to calculate totalPrice for each milk item
function calculateMilkItemTotals(deliverySchedule) {
  if (!Array.isArray(deliverySchedule)) return;
  deliverySchedule.forEach(delivery => {
    if (Array.isArray(delivery.milkItems)) {
      delivery.milkItems.forEach(item => {
        item.totalPrice = item.quantity * item.pricePerUnit;
      });
    }
  });
}

// @desc    Create a customer
// @route   POST /api/customers
// @access  Private/Admin
const createCustomer = tryCatch(async (req, res) => {
  let {
    name,
    phoneNo,
    address,
    deliverySchedule,
    password,
    username
  } = req.body;

  // Check if customer with phone number already exists
  const customerExists = await Customer.findOne({ phoneNo });

  if (customerExists) {
    return res
      .status(400)
      .json({ message: "Customer with this phone number already exists" });
  }

  // Calculate totals for milk items
  calculateMilkItemTotals(deliverySchedule);

  // If username or password are not provided, set them to phoneNo
  if (!username) username = phoneNo;
  if (!password) password = phoneNo;

  // Create customer. customerNo is auto-generated by pre-validate hook
  const customer = new Customer({
    name,
    phoneNo,
    address,
    deliverySchedule,
    username,
    password,
  });

  const createdCustomer = await customer.save();

  if (createdCustomer) {
    res.status(201).json(createdCustomer);
  } else {
    res.status(400).json({ message: "Invalid customer data" });
  }
});

// @desc    Update customer
// @route   PUT /api/customers/:id
// @access  Private/Admin
const updateCustomer = tryCatch(async (req, res) => {
  const customer = await Customer.findById(req.params.id);

  if (customer) {
    customer.name = req.body.name || customer.name;
    customer.phoneNo = req.body.phoneNo || customer.phoneNo;
    customer.address = req.body.address || customer.address;
    customer.isActive =
      req.body.isActive !== undefined ? req.body.isActive : customer.isActive;

    // Update delivery schedule if provided
    if (req.body.deliverySchedule) {
      calculateMilkItemTotals(req.body.deliverySchedule);
      customer.deliverySchedule = req.body.deliverySchedule;
    }

    // If phone number is updated, update username too (unless explicitly provided)
    if (req.body.phoneNo && !req.body.username) {
      customer.username = req.body.phoneNo;
    }

    // If username is explicitly provided
    if (req.body.username) {
      customer.username = req.body.username;
    }

    // If password is provided
    if (req.body.password) {
      customer.password = req.body.password;
    }

    const updatedCustomer = await customer.save();

    res.json(updatedCustomer);
  } else {
    res.status(404).json({ message: "Customer not found" });
  }
});

// @desc    Delete customer
// @route   DELETE /api/customers/:id
// @access  Private/Admin
const deleteCustomer = tryCatch(async (req, res) => {
  const customer = await Customer.findById(req.params.id);

  if (!customer) {
    return res.status(404).json({ message: "Customer not found" });
  }

  // Check if customer has any associated data (like orders, deliveries, etc.)
  // This is a placeholder - implement actual checks based on your data model
  const hasAssociatedData = false; // Replace with actual checks

  if (hasAssociatedData) {
    return res.status(400).json({
      message: "Cannot delete customer with associated data. Please remove associated data first."
    });
  }

  // Perform permanent delete
  await Customer.findByIdAndDelete(req.params.id);

  res.json({
    message: "Customer successfully deleted",
    customerId: customer._id
  });
});

// @desc    Auth customer & get token
// @route   POST /api/customers/login
// @access  Public
const authCustomer = tryCatch(async (req, res) => {
  const { username, password } = req.body;

  console.log("Username:", username);
  console.log("Password:", password);
  const customer = await Customer.findOne({ username, isActive: true });

  if (customer && (await customer.matchPassword(password))) {
    res.json({
      _id: customer._id,
      customerNo: customer.customerNo,
      name: customer.name,
      phoneNo: customer.phoneNo,
      address: customer.address,
      deliverySchedule: customer.deliverySchedule,
      totalDailyQuantity: customer.totalDailyQuantity,
      totalDailyPrice: customer.totalDailyPrice,
      username: customer.username,
      isActive: customer.isActive,
      token: generateToken(customer._id),
      createdAt: customer.createdAt,
      updatedAt: customer.updatedAt
    });
  } else {
    res.status(401).json({ message: "Invalid username or password" });
  }
});

export {
  getCustomers,
  getCustomerById,
  createCustomer,
  updateCustomer,
  deleteCustomer,
  authCustomer,
};
